---
title: Actions
---

Actions are the primary way for Daydreams agents to interact with the outside
world and modify their internal state. They function as a bridge between the
LLM's reasoning capabilities and actual functionality.

## How Actions Work

When you define an action in Daydreams, you're creating a function that the LLM
can call during its reasoning process. Here's what happens behind the scenes:

1.  Your action definitions are formatted (usually as XML) and injected into the
    LLM's prompt.
2.  The LLM decides to call an action based on its reasoning.
3.  Daydreams intercepts this call, validates the parameters against the
    action's `schema`, and executes your `handler` function.
4.  The result (`ActionResult`) is returned to the agent's internal state,
    making it available for subsequent reasoning steps.

This creates a powerful feedback loop where the LLM can take actions, observe
results, and adjust its approach accordingly.

## Defining an Action

Here's the basic structure of an action using the `action` helper:

```ts
import { action } from "@daydreamsai/core";
import { z } from "zod";

action({
  // Required: Name used by the LLM to reference this action
  name: "searchDatabase",

  // Required: Description helps the LLM understand when to use this action
  description: "Search the database for records matching the query",

  // Optional (but recommended): Zod schema defines and validates parameters
  schema: z.object({
    query: z.string().describe("Search query"),
    limit: z.number().optional().describe("Maximum number of results"),
  }),

  // Required: Handler function that executes when the action is called
  // 'args' contains the validated arguments matching the schema.
  // 'ctx' is the ActionCallContext, providing access to state and utilities.
  // 'agent' is the main agent instance.
  handler(args, ctx, agent) {
    const { query, limit = 10 } = args;

    // Example: Access a database client from the DI container
    // const database = agent.container.resolve<DatabaseClient>('db');
    // const results = database.search(query, limit);

    // Simulate database search
    const results = [{ id: 1, value: `Result for ${query}` }];

    // Return results (will be wrapped in an ActionResult)
    return {
      results,
      count: results.length,
      message: `Found ${results.length} results for "${query}"`,
    };
  },

  // --- Other Optional Properties ---
  // See 'Advanced Configuration' section below for more details
  // memory: actionMemory,        // Dedicated persistent memory for this action
  // enabled: (ctx) => true,      // Conditionally enable/disable
  // callFormat: "json",          // How LLM should format arguments ('json' or 'xml')
  // returns: z.object({...}),    // Schema for the expected return value
  // retry: 3,                    // Retry configuration
  // onError: (err, ctx, agent) => { /*...*/ }, // Error handling
  // onSuccess: (res, ctx, agent) => { /*...*/ }, // Success handling
  // examples: ['<action_call name="searchDatabase">...</action_call>'] // Examples for LLM
});
```

## Mutating Context State

Actions can modify the persistent state associated with the **current context
instance**. This allows the LLM to maintain and update information across
multiple interactions within that specific context.

```ts
action({
  name: "addTask",
  description: "Add a new task to the task list for the current context",
  schema: z.object({
    title: z.string().describe("Task title"),
    priority: z.enum(["low", "medium", "high"]).describe("Task priority"),
    dueDate: z.string().optional().describe("Due date in YYYY-MM-DD format"),
  }),
  // Note: 'args' holds the validated data based on the schema
  handler(args, ctx, agent) {
    // Access the persistent memory of the **current context instance**
    // IMPORTANT: Use `ctx.memory` for the current context's state.
    const contextMemory = ctx.memory;

    // Ensure the tasks array exists
    if (!contextMemory.tasks) {
      contextMemory.tasks = [];
    }

    // Create a new task object
    const newTask = {
      id: agent.utils.randomUUIDv7(), // Use agent utilities if available
      title: args.title,
      priority: args.priority,
      dueDate: args.dueDate,
      status: "pending",
      createdAt: new Date().toISOString(),
    };

    // Update the context instance's state by adding the task
    contextMemory.tasks.push(newTask);

    // The changes to `ctx.memory` will be persisted at the end of the run.

    return {
      task: newTask,
      message: `Added task "${args.title}" with ${args.priority} priority`,
    };
  },
});
```

**Understanding Memory Scopes in Actions (`ctx`):**

When working within an action's `handler`, the `ctx` object
(`ActionCallContext`) provides access to different memory scopes:

- `ctx.memory`: The persistent memory specific to the **current context
  instance** (e.g., the specific chat session or project this action is running
  for). Use this for instance-specific state.
- `ctx.agentMemory`: The persistent memory of the **agent's main context** (if
  one was defined globally when calling `createDreams`). Use this for global
  agent state.
- `ctx.actionMemory`: The persistent memory specific to **this action
  definition** (if configured using the `memory` option in the action). Use this
  for state that the action needs to retain across different runs or contexts.
- `ctx.workingMemory`: The temporary memory for the **current execution run**,
  containing the sequence of logs (inputs, outputs, thoughts, calls, results).
  Generally read-only within actions.

Choose the appropriate memory scope based on where the state needs to persist.
Most often, you'll interact with `ctx.memory` for context-specific data.

## Interacting with External Systems

Actions are ideal for connecting your agent to external systems like APIs or
databases:

```ts
action({
  name: "sendEmail",
  // ... (schema as before) ...
  async handler(args, ctx, agent) {
    try {
      // Example: Resolve an email service from the DI container
      // const emailService = agent.container.resolve<EmailService>('email');
      // await emailService.send({ ... });

      // Simulate sending email
      console.log(`Simulating email send to ${args.to}`);
      await new Promise((res) => setTimeout(res, 50)); // Simulate async call

      // Update the current context instance's memory to record this action
      const contextMemory = ctx.memory;
      if (!contextMemory.sentEmails) {
        contextMemory.sentEmails = [];
      }
      contextMemory.sentEmails.push({
        to: args.to,
        subject: args.subject,
        timestamp: new Date().toISOString(),
      });

      return {
        success: true,
        message: `Email sent to ${args.to}`,
      };
    } catch (error) {
      agent.logger.error("sendEmail action failed", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : String(error),
        message: `Failed to send email`,
      };
    }
  },
});
```

## Advanced Action Patterns

### Chaining Actions (via Context Memory)

Actions can build on each other by storing results in the context memory for
subsequent actions within the same or later runs.

```ts
// First action: Fetch data
action({
  name: "fetchWeatherData",
  // ... (schema as before) ...
  async handler(args, ctx, agent) {
    // Simulate API call
    const weatherData = {
      temperature: 25,
      conditions: "Sunny",
      location: args.location,
      fetchedAt: Date.now(),
    };
    // await weatherAPI.fetch(args.location);

    // Store in the *current context instance's memory*
    ctx.memory.weatherData = weatherData;

    return {
      temperature: weatherData.temperature,
      conditions: weatherData.conditions,
      location: weatherData.location,
    };
  },
});

// Second action: Analyze the data
action({
  name: "analyzeWeatherTrend",
  description: "Analyze weather trends based on fetched data",
  schema: z.object({}), // No input args needed, uses context memory
  handler(args, ctx, agent) {
    // Use data stored in the *current context instance's memory*
    const { weatherData } = ctx.memory;

    if (!weatherData) {
      return {
        error: "No weather data available. Fetch weather data first.",
      };
    }

    // Simulate analysis
    const analysis = {
      trend: "Stable",
      forecast: "Clear",
      recommendation: "Enjoy the sun!",
    };
    // const analysis = analyzeWeatherTrends(weatherData);

    return {
      trend: analysis.trend,
      forecast: analysis.forecast,
      recommendation: analysis.recommendation,
    };
  },
});
```

_Note: For direct data passing between actions **within the same LLM turn**, see
the Template Engine section in the
[Prompting docs](./prompting#template-engine-...)._

### Conditional Actions (using Context Memory)

```ts
action({
  name: "completeTask",
  // ... (schema as before) ...
  handler(args, ctx, agent) {
    // Access the current context instance's memory
    const contextMemory = ctx.memory;
    const tasks = contextMemory.tasks || [];
    const taskIndex = tasks.findIndex((t: any) => t.id === args.taskId);

    if (taskIndex === -1) {
      return {
        success: false,
        message: `Task with ID ${args.taskId} not found`,
      };
    }

    const completedTask = {
      ...tasks[taskIndex],
      status: "completed",
      completedAt: new Date().toISOString(),
    };

    // Update context state
    contextMemory.tasks.splice(taskIndex, 1); // Remove from active
    contextMemory.completedTasks = contextMemory.completedTasks || [];
    contextMemory.completedTasks.push(completedTask); // Add to completed

    return {
      success: true,
      message: `Task "${completedTask.title}" marked as complete`,
    };
  },
});
```

## How Actions Appear to the LLM

When the LLM receives the prompt, your actions are presented within the
`<available-actions>` XML block, detailing their capabilities.

```xml
<available-actions>
  <action name="searchDatabase">
    <description>Search the database for records matching the query</description>
    <schema>{/* JSON Schema for arguments */}</schema>
  </action>
  <action name="addTask">
    <description>Add a new task to the task list</description>
    <schema>{/* JSON Schema for arguments */}</schema>
  </action>
  </available-actions>
```

The LLM uses this information (name, description, schema) to decide which
actions to call and with what arguments, formatted according to the action's
`callFormat` (usually JSON).

## Advanced Configuration Options

Beyond the basics, the `action` helper accepts several other optional properties
defined in the `Action` interface (`packages/core/src/types.ts`):

- `memory`: Defines a persistent `Memory` store specifically for this action
  (accessed via `ctx.actionMemory`). Useful for action-specific state (e.g.,
  rate limits, counters).
- `enabled`: A function `(ctx: ActionContext) => boolean` to conditionally
  enable or disable the action based on the current state.
- `callFormat`: `'json' | 'xml'`. Specifies how the LLM should format the
  arguments within the `<action_call>` tag. Defaults largely based on schema
  complexity.
- `parser`: A function `(ref: ActionCall) => Args` to provide custom logic for
  parsing the LLM's argument content string into the required argument object.
- `templateResolver`: A function or boolean to control or customize how
  `{{...}}` templates in arguments are resolved.
- `returns`: A Zod schema defining the expected structure of the value returned
  by the `handler`. Can be used for validation or documentation.
- `format`: A function
  `(result: ActionResult) => string | string[] | XMLElement` to customize how
  the `ActionResult` log is formatted.
- `retry`: `boolean | number | ((failureCount: number, error: any) => boolean)`.
  Configures automatic retries via the `TaskRunner` if the handler fails.
- `onError`: An async function `(err, ctx, agent) => MaybePromise<any>` called
  if the handler throws an error (after retries). Can be used for cleanup or
  returning a specific error structure.
- `onSuccess`: An async function `(result, ctx, agent) => void` called after the
  handler successfully returns.
- `queueKey`: `string | ((ctx) => string)`. Assigns the action's execution to a
  specific queue in the `TaskRunner` for concurrency control.
- `examples`: `string[]`. Provides example `<action_call>` tags to the LLM to
  demonstrate proper usage.

## Best Practices

1.  **Clear Naming/Descriptions**: Crucial for LLM understanding.
2.  **Robust Schemas**: Use Zod with `.describe()` for clear parameter
    definitions.
3.  **Structured Returns**: Return objects with clear properties.
4.  **Graceful Error Handling**: Use `try...catch` in handlers; consider the
    `onError` hook.
5.  **Correct Memory Scope**: Use `ctx.memory` for context instance state,
    `ctx.agentMemory` for global state, `ctx.actionMemory` for action-specific
    state.
6.  **Idempotency**: Make actions safe to retry where possible.
7.  **Single Responsibility**: Keep actions focused.
8.  **Use `agent.logger`**: Log significant events or errors within handlers for
    debugging.

## Example: Document Management System (Corrected Memory Usage)

```ts
// Create a new document
action({
  name: "createDocument",
  // ... (schema as before) ...
  handler(args, ctx, agent) {
    const { title, content, tags = [] } = args;
    const contextMemory = ctx.memory; // Use current context instance memory

    const newDoc = {
      /* ... */
    };

    // Update context state
    if (!contextMemory.documents) contextMemory.documents = [];
    contextMemory.documents.push(newDoc);

    return { document: newDoc /* ... */ };
  },
});

// Search for documents
action({
  name: "searchDocuments",
  // ... (schema as before) ...
  handler(args, ctx, agent) {
    const contextMemory = ctx.memory; // Use current context instance memory
    const { documents = [] } = contextMemory;
    const { query, searchIn } = args;

    const results = documents.filter((doc: any) => {
      /* ... */
    });

    return { results, count: results.length /* ... */ };
  },
});

// Update a document
action({
  name: "updateDocument",
  // ... (schema as before) ...
  handler(args, ctx, agent) {
    const contextMemory = ctx.memory; // Use current context instance memory
    const { documents = [] } = contextMemory;
    const { documentId, updates } = args;

    const docIndex = documents.findIndex((d: any) => d.id === documentId);

    if (docIndex === -1) {
      /* ... handle not found ... */
    }

    // Update the document in the context instance's memory
    contextMemory.documents[docIndex] = {
      ...contextMemory.documents[docIndex],
      ...updates,
      updatedAt: new Date().toISOString(),
    };

    return {
      success: true,
      document: contextMemory.documents[docIndex] /* ... */,
    };
  },
});
```

This revised guide provides a more accurate and comprehensive overview of
actions within the Daydreams framework, incorporating details directly from the
core package structure.
