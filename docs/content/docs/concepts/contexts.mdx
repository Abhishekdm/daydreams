---
title: Contexts
description: Managing state, memory, and behavior for agent interactions.
---

In Daydreams, a **Context** represents a specific scope of interaction or task
for an agent. It encapsulates the state, memory, available actions, and behavior
relevant to that scope. Think of it like a dedicated workspace for the agent to
handle a particular conversation, process, or goal.

For example, you might have separate contexts for:

- Handling a Discord channel (`discord:channel`).
- Managing a Telegram chat (`telegram:chat`).
- Executing a specific trading strategy (`tradingContext`).
- Processing a user's request in a CLI session (`cli`).

Each running instance of a context maintains its own state and memory, isolated
from others.

## Defining a Context

Contexts are defined using the `context` function exported from
`@daydreamsai/core`.

```typescript
import { context, action, input, output } from "@daydreamsai/core";
import { z } from "zod";

// Example: A simple context for a chat session
const chatContext = context({
  // Required: A unique identifier for this type of context
  type: "chat",

  // Required: Zod schema defining the arguments needed to identify,
  // look up, or create a specific instance of this context.
  schema: z.object({
    sessionId: z.string(),
    userId: z.string(),
  }),

  // Optional: Function to generate a unique instance key from arguments.
  // If not provided, defaults to the 'type'. Useful when 'type' alone isn't unique enough.
  key: ({ sessionId }) => sessionId,

  // Optional: Asynchronous function called when a context instance is first created.
  // Use this to set up initial data or options specific to this instance.
  setup: async (args, settings, agent) => {
    // const userProfile = await agent.someService.getUserProfile(args.userId);
    const userProfile = { name: `User ${args.userId}`, preferences: {} }; // Simulated
    return { userProfile }; // This becomes 'options' in ContextState
  },

  // Optional: Function to define the structure of the persistent memory
  // specific to this context type (TMemory). Runs if no saved memory exists.
  create: (params, agent) => {
    return {
      messageHistory: [],
      userPreferences: params.options.userProfile?.preferences ?? {},
    };
  },

  // Optional: Provides static or dynamic instructions to the LLM within this context.
  instructions: (state) =>
    `You are chatting with ${state.options.userProfile?.name}. Be helpful.`,

  // Optional: Provides a description of the context, often used in prompts.
  description: "A chat session with a specific user.",

  // Optional: Function to render the context's state for the LLM prompt.
  // The output (string, XML, etc.) is included in the <context> section of the prompt.
  render: (state) => {
    const memory = state.memory as {
      messageHistory: { sender: string; text: string }[];
    };
    return (memory.messageHistory || [])
      .slice(-5) // Show last 5 messages
      .map((msg) => `${msg.sender}: ${msg.text}`)
      .join("\n");
  },

  // Optional: Define lifecycle hooks for the context run.
  onStep: async (ctx, agent) => {
    /* Logic to run on each step */
  },
  onRun: async (ctx, agent) => {
    /* Logic to run when the run completes */
  },
  shouldContinue: (ctx) => true, // Determine if the run should continue
  onError: async (error, ctx, agent) => {
    /* Handle errors */
  },

  // Optional: Specify a default LLM for this context type.
  model: undefined, // Defaults to agent's model if undefined

  // Optional: Default limits for runs within this context.
  maxSteps: 10,
  maxWorkingMemorySize: 50,
});
// Optionally chain methods to add context-specific components:
// .setInputs({ /* ... */ })
// .setOutputs({ /* ... */ })
// .setActions([ /* ... */ ])
// .use(myContextComposer); // For advanced composition
```

**Key Parameters:**

- `type` (string): A unique identifier for the kind of context (e.g.,
  "discord:channel", "trading").
- `schema` (Zod Schema): Defines the arguments needed to uniquely identify, look
  up, or create an _instance_ of this context (e.g.,
  `{ channelId: z.string() }`).
- `key` (Function, optional): Generates a unique string identifier for a context
  instance based on its arguments. If omitted, the `type` is used (suitable if
  only one instance of that type exists).
- `setup` (Function, optional): Runs once when a context instance is first
  initialized. Useful for fetching initial data needed by the context, which
  becomes available in `ContextState.options`.
- `create` (Function, optional): Defines the initial structure of the context's
  persistent memory (`TMemory`) if no saved state is found. The return value is
  stored and managed by the `MemoryStore`.
- `instructions` / `description` (string | Function, optional): Provides
  guidance to the LLM about the context's purpose or state. Can be dynamic based
  on the current `ContextState`.
- `render` (Function, optional): Determines how the context's current state
  (`ContextState.memory`) is represented in the LLM prompt (within the
  `<context>` tag).
- `onStep` / `onRun` / `shouldContinue` / `onError` (Functions, optional):
  Lifecycle hooks executed during an `agent.run`.
- **Context-Specific Components**: Use `.setInputs({...})`,
  `.setOutputs({...})`, and `.setActions([...])` after defining the context to
  add inputs, outputs, and actions available specifically when this context is
  active. These are merged with the agent's global definitions during a run.
- **Context Composition**: Use `.use(composer)` for advanced scenarios where one
  context needs to dynamically include other contexts based on its state.
- `model` (LanguageModelV1, optional): Override the agent's default model for
  runs within this context.
- `maxSteps` / `maxWorkingMemorySize` (number, optional): Set default limits for
  runs within this context.

## Context State (`ContextState`)

When a context is active during an `agent.run`, its state is represented by the
`ContextState` object. This object is passed to various handlers and functions
(like `render`, `onStep`, action handlers).

```typescript
type ContextState<TContext extends AnyContext = AnyContext> = {
  id: string; // Unique identifier for this instance (e.g., "discord:channel:12345")
  key: string; // Key generated by the `key` function (e.g., "12345")
  context: TContext; // The original context definition object
  args: InferSchemaArguments<TContext["schema"]>; // Parsed arguments used to load this instance
  options: InferContextOptions<TContext>; // Result returned by the `setup` function
  memory: InferContextMemory<TContext>; // The current persistent memory state for this instance
  settings: ContextSettings; // Runtime settings (model, limits) for this run
  contexts: string[]; // IDs of other contexts linked to this run
};
```

## Working with Context Memory

The context memory (`ContextState.memory`) is where all persistent state changes
for a specific context instance are stored. You can access and modify this
memory within action handlers to maintain state across interactions.

```typescript
action({
  name: "addItem",
  description: "Add a new item to the list",
  schema: z.object({
    item: z.string(),
  }),
  // Note: `ctx` here is the ActionCallContext
  handler(args, ctx, agent) {
    // Access the persistent memory for the *current context instance*
    // using ctx.memory
    const contextMemory = ctx.memory;

    // Update the state
    if (!contextMemory.items) {
      contextMemory.items = [];
    }
    contextMemory.items.push(args.item);

    // The change to ctx.memory will be persisted at the end of the run

    return { success: true };
  },
});
```

_Note: Remember the different memory scopes available in action handlers:
`ctx.memory` (current context instance), `ctx.agentMemory` (main agent context),
`ctx.actionMemory` (action-specific). Use the appropriate scope for your state
updates. See the [Actions documentation](./actions#mutating-context-state) for
more details._

## Context Lifecycle

1.  **Initialization**: When `agent.getContext` is called for a context instance
    for the first time:
    - The `setup` function runs (if defined) to fetch initial options.
    - The `create` function runs (if defined and no saved state exists) to set
      up the initial `memory` structure.
2.  **Identification**: The `key` function generates a unique string
    (`ContextState.key`) used to store and retrieve the instance's `memory`. The
    full instance `id` combines the `type` and `key`.
3.  **Interaction**: During an `agent.run` for this context instance:
    - Actions read and modify `ContextState.memory`.
    - The agent manages the temporary `WorkingMemory` for the run.
4.  **Rendering**: Before each LLM call within the run, the `render` function
    formats the current `ContextState.memory` for the prompt.
5.  **Persistence**: After the run (or potentially between steps, depending on
    implementation), `agent.saveContext` persists the final state of
    `ContextState.memory` using the context `id`.

## Working Memory

Each context run (`agent.run`) has an associated `WorkingMemory`. This is
distinct from the persistent `ContextState.memory`. Working Memory holds the
temporary logs (`InputRef`, `OutputRef`, `ActionCall`, `ActionResult`,
`Thought`, etc.) generated _during_ a single run. It's the agent's short-term
scratchpad for the current execution cycle and is used to build the prompt for
the LLM at each step.

See the [Agent Lifecycle documentation](./agent-lifecycle) for how Working
Memory is used in prompt generation.

## Best Practices

- Keep your `render` output concise and relevant to the LLM's task.
- Structure your persistent `memory` state logically for easy access and
  updates.
- Use descriptive keys if your context type can have multiple instances.
- Use `setup` for fetching read-only instance data, `create` for initializing
  mutable memory structure.
- Consider how multiple contexts might interact in complex agents (using
  `agent.run({ contexts: [...] })` or the `.use()` composer).
- Use Zod's `.describe()` method to add helpful descriptions to your `schema`
  fields, aiding the LLM (and developers).

## Agent Interaction

You typically interact with contexts via the `Agent` instance:

- `agent.getContext({ context: myContext, args: { ... } })`: Retrieves an
  existing `ContextState` instance or creates a new one if it doesn't exist.
  Loads memory from the `MemoryStore`.
- `agent.getContextById(id)`: Retrieves a `ContextState` by its full ID (e.g.,
  "discord:channel:12345").
- `agent.saveContext(contextState)`: Persists the `ContextState` (including its
  `memory`) to the configured `MemoryStore`. This is often handled automatically
  by the agent lifecycle.
- `agent.run({ context: myContext, args: { ... } })`: Starts or continues the
  execution loop for a specific context instance.

## Example: Task Manager Context

Here's a more complete example of a task manager context:

```typescript
import { context } from "@daydreamsai/core";
import { z, string } from "zod";

// Define memory structure for tasks
interface Task {
  id: string;
  title: string;
  status: "pending" | "completed";
  // ... other task properties
}

interface TaskManagerMemory {
  tasks: Task[];
  completedTasks: Task[];
  currentTask: Task | null;
  projectName: string;
}

const taskManagerContext = context<
  TaskManagerMemory,
  { projectId: string; userId: string }
>({
  type: "task-manager",
  schema: z.object({
    projectId: string().describe("Unique identifier for the project"),
    userId: string().describe("User who owns this task list"),
  }),
  key: ({ projectId, userId }) => `${userId}:${projectId}`, // Instance per user per project
  create: (state) => {
    // Initializes ContextState.memory
    return {
      tasks: [],
      completedTasks: [],
      currentTask: null,
      projectName: state.args.projectId || "Unnamed Project", // Use args here
    };
  },
  render: ({ memory }) => {
    // Renders ContextState.memory for the LLM
    const taskList = memory.tasks
      .map((task) => `- ${task.title} (${task.status})`)
      .join("\n");
    const completedList = memory.completedTasks
      .map((task) => `- ${task.title}`)
      .join("\n");

    return `
# Task Manager: ${memory.projectName}

## Current Tasks:
${taskList || "No active tasks"}

## Current Focus:
${memory.currentTask ? `Working on: ${memory.currentTask.title}` : "No task in focus"}

## Completed Tasks:
${completedList || "No completed tasks"}
    `;
  },
  // ... (actions like addTask, completeTask would be defined here or globally)
});
```

Contexts provide the essential structure for managing scoped state, behavior,
and memory within the Daydreams framework.
