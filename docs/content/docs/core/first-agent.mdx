---
title: Your first agent
description:
  Build your first Daydreams agent and discover the power of contexts.
---

import { Tab, Tabs } from "fumadocs-ui/components/tabs";

## What Makes Daydreams Different?

Most AI frameworks treat conversations as stateless - every interaction starts
from scratch. But real conversations aren't like that. **Daydreams changes
everything with contexts.**

### The Magic of Contexts

Imagine you're building a customer support agent. With traditional frameworks:

```text title="traditional-stateless-approach.txt"
User: "I need help with my order"
Agent: "What's your order number?"
User: "12345"
Agent: "What's your order number?" // ðŸ˜• Already forgot!
```

With Daydreams contexts:

```text title="daydreams-stateful-approach.txt"
User: "I need help with my order"
Agent: "What's your order number?"
User: "12345"
Agent: "I see order #12345. It was shipped yesterday!" // ðŸŽ‰ Remembers!
```

**Contexts are isolated workspaces** that:

- ðŸ§  **Remember** - Each conversation has its own memory
- ðŸ”’ **Isolate** - Different users never see each other's data
- ðŸŽ¯ **Focus** - Specialized behaviors for different situations
- ðŸ”„ **Persist** - Memory survives between conversations

## How Daydreams Works

An agent in Daydreams follows this cycle:

1. **Listen** - Receives input (message, event, API call)
2. **Think** - Uses an LLM to understand and decide
3. **Act** - Performs actions or sends responses
4. **Remember** - Saves important information in context

This happens continuously, with the context providing memory and state
throughout.

## Installation

Let's build your first stateful agent! Start by installing Daydreams:

<Tabs groupId="language" items={["pnpm", "npm", "bun", "yarn"]} persist>
  <Tab value="pnpm">
    pnpm add @daydreamsai/core @daydreamsai/cli @ai-sdk/openai zod
  </Tab>
  <Tab value="npm">
    npm install @daydreamsai/core @daydreamsai/cli @ai-sdk/openai zod
  </Tab>
  <Tab value="bun">
    bun add @daydreamsai/core @daydreamsai/cli @ai-sdk/openai zod
  </Tab>
  <Tab value="yarn">
    yarn add @daydreamsai/core @daydreamsai/cli @ai-sdk/openai zod
  </Tab>
</Tabs>

**Important:** Set your `OPENAI_API_KEY` environment variable before continuing.

## Your First Context-Aware Agent

Let's build a personal assistant that remembers you - your name, preferences,
and conversation history. This showcases the true power of contexts.

### Step 1: Create your project

```bash title="setup.sh"
mkdir my-first-agent && cd my-first-agent
touch agent.ts
```

### Step 2: Build a stateful agent

```typescript title="agent.ts"
import { createDreams, context, action } from "@daydreamsai/core";
import { cliExtension } from "@daydreamsai/cli";
import { openai } from "@ai-sdk/openai";
import * as z from "zod";

// Define what our assistant remembers about each user
interface AssistantMemory {
  userName?: string;
  preferences: Record<string, any>;
  conversationCount: number;
  lastTopic?: string;
}

// Create a context - this is where the magic happens!
const assistantContext = context<AssistantMemory>({
  type: "personal-assistant",

  // Each user gets their own context instance
  schema: z.object({
    userId: z.string().describe("Unique identifier for the user"),
  }),

  // Initialize memory for new users
  create: () => ({
    preferences: {},
    conversationCount: 0,
  }),

  // Define what the LLM sees about this context
  render: (state) => {
    const { userName, conversationCount, lastTopic, preferences } =
      state.memory;

    return `
Personal Assistant for User: ${state.args.userId}
${userName ? `Name: ${userName}` : "Name: Unknown (ask for their name!)"}
Conversations: ${conversationCount}
${lastTopic ? `Last topic: ${lastTopic}` : ""}
${
  Object.keys(preferences).length > 0
    ? `Preferences: ${JSON.stringify(preferences, null, 2)}`
    : "No preferences saved yet"
}
    `.trim();
  },

  // Instructions that guide the assistant's behavior
  instructions: `You are a personal assistant with memory. You should:
- Remember information about the user across conversations
- Ask for their name if you don't know it
- Learn their preferences over time
- Reference previous conversations when relevant
- Be helpful and personalized based on what you know`,

  // Track conversation count
  onRun: async (ctx) => {
    ctx.memory.conversationCount++;
  },
});

// Add actions the assistant can perform
assistantContext.setActions([
  action({
    name: "remember-name",
    description: "Remember the user's name",
    schema: z.object({
      name: z.string().describe("The user's name"),
    }),
    handler: async ({ name }, ctx) => {
      ctx.memory.userName = name;
      return {
        remembered: true,
        message: `I'll remember your name is ${name}`,
      };
    },
  }),

  action({
    name: "save-preference",
    description: "Save a user preference",
    schema: z.object({
      key: z.string().describe("Preference category"),
      value: z.string().describe("Preference value"),
    }),
    handler: async ({ key, value }, ctx) => {
      ctx.memory.preferences[key] = value;
      return {
        saved: true,
        message: `Noted! Your ${key} preference is ${value}`,
      };
    },
  }),

  action({
    name: "update-topic",
    description: "Remember what we're discussing",
    schema: z.object({
      topic: z.string().describe("Current conversation topic"),
    }),
    handler: async ({ topic }, ctx) => {
      ctx.memory.lastTopic = topic;
      return { updated: true };
    },
  }),
]);

// Create the agent
const agent = createDreams({
  model: openai("gpt-4o-mini"),
  extensions: [cliExtension],
  contexts: [assistantContext],
});

// Start the interactive CLI
async function main() {
  await agent.start();

  console.log("\nðŸ¤– Personal Assistant Started!");
  console.log("ðŸ’¡ Try telling me your name or preferences.");
  console.log("ðŸ’¡ Exit and restart - I'll still remember you!\n");

  // Simulate different users with different context instances
  const userId = process.argv[2] || "default-user";
  console.log(`Starting session for user: ${userId}\n`);

  // Run the assistant for this specific user
  await agent.run({
    context: assistantContext,
    args: { userId }, // This creates/loads a unique context instance
  });

  console.log("\nðŸ‘‹ See you next time!");
}

main().catch(console.error);
```

### Step 3: Experience the magic of contexts

Run your agent:

```bash title="run.sh"
# Start as the default user
node agent.ts

# Or start as a specific user
node agent.ts alice
node agent.ts bob
```

Try this conversation flow:

```text title="example-conversation.txt"
You: Hi there!
Assistant: Hello! I don't think we've been properly introduced. What's your name?

You: I'm Alice
Assistant: Nice to meet you, Alice! I'll remember that for next time.

You: I love coffee and hate mornings
Assistant: I've noted your preferences! You love coffee and hate mornings.

You: What do you know about me?
Assistant: I know your name is Alice, you love coffee, and you hate mornings.
          We've had 1 conversation so far.

[Exit and restart the agent with 'node agent.ts alice']

You: Do you remember me?
Assistant: Of course, Alice! I remember you love coffee and hate mornings.
          This is our 2nd conversation together.
```

### What Just Happened?

1. **Context Creation** - When you started with user "alice", Daydreams created
   a unique context instance
2. **Memory Persistence** - The context saved Alice's name and preferences
3. **Isolation** - If you run `node agent.ts bob`, Bob gets a completely
   separate context
4. **Stateful Behavior** - The agent's responses are personalized based on
   context memory

## Understanding Context Power

Let's see how contexts solve real problems:

### Problem 1: Multi-User Support

```typescript title="multi-user-contexts.ts"
// Each user automatically gets their own isolated context
await agent.run({
  context: assistantContext,
  args: { userId: "alice" }, // Alice's personal workspace
});

await agent.run({
  context: assistantContext,
  args: { userId: "bob" }, // Bob's separate workspace
});

// Alice and Bob never see each other's data!
```

### Problem 2: Different Behaviors for Different Situations

```typescript title="multiple-context-types.ts"
// Different contexts for different purposes
const casualChatContext = context({
  type: "casual-chat",
  instructions: "Be friendly and conversational",
});

const technicalSupportContext = context({
  type: "tech-support",
  instructions: "Be precise and solution-focused",
});

const salesContext = context({
  type: "sales",
  instructions: "Be helpful but also mention relevant products",
});

// Same agent, different personalities based on context!
```

### Problem 3: Complex State Management

```typescript title="complex-state.ts"
interface GameMemory {
  level: number;
  score: number;
  inventory: string[];
  currentRoom: string;
}

const gameContext = context<GameMemory>({
  type: "adventure-game",
  create: () => ({
    level: 1,
    score: 0,
    inventory: ["torch"],
    currentRoom: "entrance",
  }),
  // Game state persists between sessions!
});
```

## Key Concepts to Remember

1. **Contexts = Isolated Workspaces**

   - Each context instance has its own memory
   - Perfect for multi-user applications
   - No data leakage between contexts

2. **Contexts = Persistent Memory**

   - State survives between conversations
   - Build agents that truly remember
   - No more stateless interactions

3. **Contexts = Specialized Behavior**
   - Different instructions for different situations
   - Same agent, multiple personalities
   - Clean separation of concerns

## Next Steps

Now that you understand the power of contexts, explore:

- **[Contexts Deep Dive](/docs/core/concepts/contexts)** - Master context
  features
- **[Composing Contexts](/docs/core/concepts/composing-contexts)** - Combine
  contexts for complex behaviors
- **[Building Blocks](/docs/core/concepts/building-blocks)** - Understand all
  agent components
- **[Real Examples](/docs/tutorials)** - See contexts in action

### Quick Challenges

1. **Add a mood tracker** - Make the assistant remember and respond to your mood
2. **Build a todo context** - Create a separate context for managing tasks
3. **Add user authentication** - Use context args to implement simple auth

## Remember This

**Contexts are what make Daydreams special.** They transform simple chatbots
into intelligent agents with real memory, proper isolation, and specialized
behaviors.

Every time you think "I wish my agent could remember...", that's what contexts
are for!
